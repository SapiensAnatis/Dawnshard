using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace DragaliaAPI.Shared.SourceGenerator;

[Generator]
public class MasterAssetGenerator : IIncrementalGenerator
{
    private const string Namespace = "DragaliaAPI.Shared.MasterAsset";
    private const string GenerateAttributeName = "GenerateMasterAssetAttribute";
    private const string ExtendAttributeName = "ExtendMasterAssetAttribute";

    private const string AttributeSourceCode = $$"""
        // <auto-generated/>

        #nullable enable

        namespace {{Namespace}};

        [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
        public sealed class {{GenerateAttributeName}}<TItem> : System.Attribute
            where TItem : class
        {
            public {{GenerateAttributeName}}(string filepath)
            {
                this.Filepath = filepath;
            }

            public string Filepath { get; }
            
            public string Key { get; set; } = "Id";

            public bool Group { get; set; }
        }

        [global::System.AttributeUsage(global::System.AttributeTargets.Property, AllowMultiple = false, Inherited = false)]
        public sealed class {{ExtendAttributeName}} : System.Attribute
        {
            public {{ExtendAttributeName}}(string masterAssetName)
            {
                this.MasterAssetName = masterAssetName;
            }
            
            public string MasterAssetName { get; }
            
            public string? FeatureFlag { get; }
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource(
                "GenerateMasterAssetAttribute.g.cs",
                SourceText.From(AttributeSourceCode, Encoding.UTF8)
            )
        );

        IncrementalValuesProvider<MasterAssetDeclaration> declarationProvider = context
            .SyntaxProvider.ForAttributeWithMetadataName(
                $"{Namespace}.{GenerateAttributeName}`1",
                static (_, _) => true,
                Transforms.TransformMasterAssetDeclarations
            )
            .SelectMany(static (list, _) => list.AsEnumerable());

        IncrementalValueProvider<
            ImmutableArray<MasterAssetExtensionDeclaration>
        > extensionProvider = context
            .SyntaxProvider.ForAttributeWithMetadataName(
                $"{Namespace}.{ExtendAttributeName}",
                static (_, _) => true,
                Transforms.TransformExtensionDeclarations
            )
            .Collect();

        IncrementalValuesProvider<(
            MasterAssetDeclaration Left,
            MasterAssetExtensionDeclaration? Right
        )> joined = declarationProvider
            .Combine(extensionProvider)
            .Select(
                (tuple, _) =>
                {
                    return (
                        tuple.Left,
                        tuple.Right.FirstOrDefault(extension =>
                            extension.MasterAssetName == tuple.Left.PropertyName
                        )
                    );
                }
            );

        context.RegisterSourceOutput(joined.Collect(), GenerateCode);
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<(
            MasterAssetDeclaration Left,
            MasterAssetExtensionDeclaration? Right
        )> declarations
    )
    {
        const string masterAssetTypeName = "global::DragaliaAPI.Shared.MasterAsset.MasterAssetData";
        const string masterAssetGroupTypeName =
            "global::DragaliaAPI.Shared.MasterAsset.MasterAssetGroup";

        CodeStringBuilder codeBuilder = new();
        codeBuilder.AppendLine(
            $$"""
            // <auto-generated/>

            #nullable enable

            namespace {{Namespace}};

            public static partial class MasterAsset
            {
            """
        );

        codeBuilder.IncreaseIndent();

        codeBuilder.AppendLine(
            """
            private const string ErrorUninitialized = "Property access failed: MasterAsset is not yet initialized. Call LoadAsync before accessing any properties.";

            private static bool loaded;
            """
        );

        foreach ((MasterAssetDeclaration declaration, _) in declarations)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            codeBuilder.AppendLine();

            string propertyName = declaration.PropertyName;
            string fieldName = declaration.FieldName;

            // The outer key in MasterAssetGroup is restricted to be int when using this generator.
            // Can revisit this if other types are required later.
            string typeName = declaration.IsGroup
                ? $"{masterAssetGroupTypeName}<int, {declaration.FullyQualifiedKeyTypeName}, {declaration.FullyQualifiedItemTypeName}>"
                : $"{masterAssetTypeName}<{declaration.FullyQualifiedKeyTypeName}, {declaration.FullyQualifiedItemTypeName}>";

            codeBuilder.AppendLine($"private static {typeName}? {fieldName};");

            codeBuilder.AppendLine(
                $"public static {typeName} {propertyName} => {fieldName} ?? throw new InvalidOperationException(ErrorUninitialized);"
            );
        }

        codeBuilder.AppendLine(
            $$"""
            public static async Task LoadAsync()
            {
            """
        );

        codeBuilder.IncreaseIndent();

        codeBuilder.AppendLine(
            """
            if (loaded)
            {
                return;
            }
            """
        );

        foreach (
            (
                MasterAssetDeclaration declaration,
                MasterAssetExtensionDeclaration? extension
            ) in declarations
        )
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            string msgpackPath = declaration.JsonPath.Replace(".json", ".msgpack");
            string taskName = declaration.TaskName;

            string typeName = declaration.IsGroup
                ? $"{masterAssetGroupTypeName}<int, {declaration.FullyQualifiedKeyTypeName}, {declaration.FullyQualifiedItemTypeName}>"
                : $"{masterAssetTypeName}<{declaration.FullyQualifiedKeyTypeName}, {declaration.FullyQualifiedItemTypeName}>";

            string loadMethodName = declaration.IsGroup
                ? $"{masterAssetGroupTypeName}.LoadAsync<int, {declaration.FullyQualifiedKeyTypeName}, {declaration.FullyQualifiedItemTypeName}>"
                : $"{masterAssetTypeName}.LoadAsync<{declaration.FullyQualifiedKeyTypeName}, {declaration.FullyQualifiedItemTypeName}>";

            codeBuilder.AppendLine(
                $"""
                global::System.Threading.Tasks.ValueTask<{typeName}> {taskName} =
                    {loadMethodName}(
                        "{msgpackPath}",
                        ({declaration.FullyQualifiedItemTypeName} x) => x.{declaration.KeyName}{(
                    declaration.IsGroup ? "": ","
                )}
                """
            );

            codeBuilder.IncreaseIndent();
            codeBuilder.IncreaseIndent();

            if (!declaration.IsGroup)
            {
                codeBuilder.AppendLine(extension is not null ? extension.DataPath : "null");
            }

            codeBuilder.DecreaseIndent();
            codeBuilder.AppendLine(");");
            codeBuilder.DecreaseIndent();
        }

        codeBuilder.AppendLine();

        foreach ((MasterAssetDeclaration declaration, _) in declarations)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            codeBuilder.AppendLine($"{declaration.FieldName} = await {declaration.TaskName};");
        }

        codeBuilder.AppendLine("loaded = true;");
        codeBuilder.DecreaseIndent();
        codeBuilder.AppendLine("}");
        codeBuilder.DecreaseIndent();
        codeBuilder.AppendLine("}");

        context.AddSource(
            "MasterAsset.g.cs",
            SourceText.From(codeBuilder.ToString(), Encoding.UTF8)
        );
    }
}
