using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace DragaliaAPI.Shared.SourceGenerator;

[Generator]
public class MasterAssetGenerator : IIncrementalGenerator
{
    private const string Namespace = "DragaliaAPI.Shared.MasterAsset";
    private const string GenerateAttributeName = "GenerateMasterAssetAttribute";
    private const string ExtendAttributeName = "ExtendMasterAssetAttribute";

    private const string AttributeSourceCode = $$"""
        // <auto-generated/>

        #nullable enable

        namespace {{Namespace}};

        [global::System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
        public sealed class {{GenerateAttributeName}}<TItem> : System.Attribute
            where TItem : class
        {
            public {{GenerateAttributeName}}(string filepath)
            {
                this.Filepath = filepath;
            }

            public string Filepath { get; }
            
            public string Key { get; set; } = "Id";

            public bool Group { get; set; }
        }

        [global::System.AttributeUsage(global::System.AttributeTargets.Assembly, AllowMultiple = true, Inherited = false)]
        public sealed class {{ExtendAttributeName}} : System.Attribute
        {
            public {{ExtendAttributeName}}(string masterAssetName, string filepath)
            {
                this.MasterAssetName = masterAssetName;
                this.Filepath = filepath;
            }
            
            public string MasterAssetName { get; }
            
            public string Filepath { get; }
            
            public string? FeatureFlag { get; set; }
        }
        """;

    private const string MessagePackOptionsSourceCode = $$"""
        // <auto-generated/>

        #nullable enable

        namespace {{Namespace}};

        public class MasterAssetMessagePackOptions
        {
            public static global::MessagePack.MessagePackSerializerOptions Instance { get; } =
                global::MessagePack.MessagePackSerializerOptions
                    .Standard.WithResolver(global::MessagePack.Resolvers.ContractlessStandardResolver.Instance)
                    .WithCompression(global::MessagePack.MessagePackCompression.Lz4BlockArray);
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource(
                "GenerateMasterAssetAttribute.g.cs",
                SourceText.From(AttributeSourceCode, Encoding.UTF8)
            )
        );

        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource(
                "MasterAssetMessagePackOptions.g.cs",
                SourceText.From(MessagePackOptionsSourceCode, Encoding.UTF8)
            )
        );

        IncrementalValueProvider<
            ImmutableArray<MasterAssetExtensionDeclaration>
        > extensionProvider = context
            .SyntaxProvider.ForAttributeWithMetadataName(
                $"{Namespace}.{ExtendAttributeName}",
                static (_, _) => true,
                Transforms.TransformExtensionDeclarations
            )
            .SelectMany(static (list, _) => list.AsEnumerable())
            .Collect();

        IncrementalValuesProvider<MasterAssetDeclaration> declarationProvider = context
            .SyntaxProvider.ForAttributeWithMetadataName(
                $"{Namespace}.{GenerateAttributeName}`1",
                static (_, _) => true,
                Transforms.TransformMasterAssetDeclarations
            )
            .SelectMany(static (list, _) => list.AsEnumerable());

        IncrementalValuesProvider<MasterAssetInstance> join = declarationProvider
            .Combine(extensionProvider)
            .Select(
                static (tuple, _) =>
                {
                    return new MasterAssetInstance(
                        tuple.Left,
                        tuple
                            .Right.Where(extension =>
                                extension?.MasterAssetName == tuple.Left.PropertyName
                            )
                            .ToEquatableReadOnlyList()
                    );
                }
            );

        IncrementalValueProvider<ImmutableArray<MasterAssetInstance>> collected = join.Collect();

        context.RegisterSourceOutput(collected, GenerateMasterAssets);
        context.RegisterSourceOutput(collected, GenerateExtensions);
    }

    private static void GenerateMasterAssets(
        SourceProductionContext context,
        ImmutableArray<MasterAssetInstance> masterAssets
    )
    {
        const string masterAssetTypeName = "global::DragaliaAPI.Shared.MasterAsset.MasterAssetData";
        const string masterAssetGroupTypeName =
            "global::DragaliaAPI.Shared.MasterAsset.MasterAssetGroup";

        CodeStringBuilder codeBuilder = new();
        codeBuilder.AppendLine(
            $$"""
            // <auto-generated/>

            #nullable enable

            namespace {{Namespace}};

            public static partial class MasterAsset
            {
            """
        );

        codeBuilder.IncreaseIndent();

        codeBuilder.AppendLine(
            """
            private const string ErrorUninitialized = "Property access failed: MasterAsset is not yet initialized. Call LoadAsync before accessing any properties.";

            private static bool loaded;
            """
        );

        foreach ((MasterAssetDeclaration declaration, _) in masterAssets)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            codeBuilder.AppendLine();

            string propertyName = declaration.PropertyName;
            string fieldName = declaration.FieldName;

            // The outer key in MasterAssetGroup is restricted to be int when using this generator.
            // Can revisit this if other types are required later.
            string typeName = declaration.IsGroup
                ? $"{masterAssetGroupTypeName}<int, {declaration.KeyTypeName}, {declaration.ItemTypeName}>"
                : $"{masterAssetTypeName}<{declaration.KeyTypeName}, {declaration.ItemTypeName}>";

            codeBuilder.AppendLine($"private static {typeName}? {fieldName};");

            codeBuilder.AppendLine(
                $"public static {typeName} {propertyName} => {fieldName} ?? throw new InvalidOperationException(ErrorUninitialized);"
            );
        }

        codeBuilder.AppendLine(
            $$"""
            public static async Task LoadAsync(global::Microsoft.FeatureManagement.IFeatureManager featureManager)
            {
            """
        );

        codeBuilder.IncreaseIndent();

        codeBuilder.AppendLine(
            """
            if (loaded)
            {
                return;
            }
            """
        );

        foreach (
            (
                MasterAssetDeclaration declaration,
                EquatableReadOnlyList<MasterAssetExtensionDeclaration> extensions
            ) in masterAssets
        )
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            string msgpackPath = declaration.JsonPath.Replace(".json", ".msgpack");
            string taskName = declaration.TaskName;

            string typeName = declaration.IsGroup
                ? $"{masterAssetGroupTypeName}<int, {declaration.KeyTypeName}, {declaration.ItemTypeName}>"
                : $"{masterAssetTypeName}<{declaration.KeyTypeName}, {declaration.ItemTypeName}>";

            string loadMethodName = declaration.IsGroup
                ? $"{masterAssetGroupTypeName}.LoadAsync<int, {declaration.KeyTypeName}, {declaration.ItemTypeName}>"
                : $"{masterAssetTypeName}.LoadAsync<{declaration.KeyTypeName}, {declaration.ItemTypeName}>";

            codeBuilder.AppendLine(
                $"""
                
                global::System.Threading.Tasks.ValueTask<{typeName}> {taskName} =
                    {loadMethodName}(
                        "{msgpackPath}",
                        ({declaration.ItemTypeName} x) => x.{declaration.KeyName}{(
                    declaration.IsGroup ? "": ","
                )}
                """
            );

            codeBuilder.IncreaseIndent();
            codeBuilder.IncreaseIndent();

            if (!declaration.IsGroup)
            {
                if (extensions.Count != 0)
                {
                    codeBuilder.AppendLine(
                        $"await Load{declaration.PropertyName}Extension(featureManager)"
                    );
                }
                else
                {
                    codeBuilder.AppendLine("null");
                }
            }

            codeBuilder.DecreaseIndent();
            codeBuilder.AppendLine(");");
            codeBuilder.DecreaseIndent();
        }

        codeBuilder.AppendLine();

        foreach ((MasterAssetDeclaration declaration, _) in masterAssets)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            codeBuilder.AppendLine($"{declaration.FieldName} = await {declaration.TaskName};");
        }

        codeBuilder.AppendLine("loaded = true;");
        codeBuilder.DecreaseIndent();
        codeBuilder.AppendLine("}");
        codeBuilder.DecreaseIndent();
        codeBuilder.AppendLine("}");

        context.AddSource(
            "MasterAsset.g.cs",
            SourceText.From(codeBuilder.ToString(), Encoding.UTF8)
        );
    }

    private static void GenerateExtensions(
        SourceProductionContext context,
        ImmutableArray<MasterAssetInstance> masterAssets
    )
    {
        CodeStringBuilder codeBuilder = new();

        codeBuilder.AppendLine(
            $$"""
            // <auto-generated/>

            #nullable enable

            namespace {{Namespace}};

            public static partial class MasterAsset
            {
            """
        );

        codeBuilder.IncreaseIndent();

        codeBuilder.AppendLine(
            """
            private static async Task<List<TItem>> LoadFile<TItem>(string msgpackPath)
            {
                string path = Path.Join(
                   global::System.IO.Path.GetDirectoryName(global::System.Reflection.Assembly.GetExecutingAssembly().Location),
                    "Resources",
                    msgpackPath
                );

                await using FileStream fs = File.OpenRead(path);

                return await global::MessagePack.MessagePackSerializer.DeserializeAsync<List<TItem>>(
                    fs,
                    MasterAssetMessagePackOptions.Instance
                ) ?? throw new global::MessagePack.MessagePackSerializationException($"Deserialized MasterAsset extension for {path} was null");
            }
            """
        );

        foreach (
            (
                MasterAssetDeclaration declaration,
                EquatableReadOnlyList<MasterAssetExtensionDeclaration> extensions
            ) in masterAssets
        )
        {
            if (extensions.Count == 0)
            {
                continue;
            }

            const string task = "global::System.Threading.Tasks.Task";
            const string list = "global::System.Collections.Generic.IEnumerable";
            const string featureManager = "global::Microsoft.FeatureManagement.IFeatureManager";

            codeBuilder.AppendLine(
                $$"""

                public static async {{task}}<{{list}}<{{declaration.ItemTypeName}}>> Load{{declaration.PropertyName}}Extension({{featureManager}} featureManager)
                {
                    global::System.Collections.Generic.List<{{declaration.ItemTypeName}}> extendedData = [];
                    
                """
            );

            codeBuilder.IncreaseIndent();

            foreach (MasterAssetExtensionDeclaration extension in extensions)
            {
                string filepath = extension.FilePath.Replace(".json", ".msgpack");
                string loadSyntax = $"""
                    extendedData.AddRange(await LoadFile<{declaration.ItemTypeName}>("{filepath}"));
                    """;

                if (extension.FeatureFlag is not null)
                {
                    codeBuilder.AppendLine(
                        $$"""
                        if (await featureManager.IsEnabledAsync("{{extension.FeatureFlag}}"))
                        {
                            {{loadSyntax}}
                        }
                        """
                    );
                }
                else
                {
                    codeBuilder.AppendLine(loadSyntax);
                }
            }

            codeBuilder.AppendLine();
            codeBuilder.AppendLine("return extendedData;");

            codeBuilder.DecreaseIndent();
            codeBuilder.AppendLine("}");
        }

        codeBuilder.DecreaseIndent();
        codeBuilder.AppendLine("}");

        context.AddSource(
            "MasterAsset.Extensions.g.cs",
            SourceText.From(codeBuilder.ToString(), Encoding.UTF8)
        );
    }
}
