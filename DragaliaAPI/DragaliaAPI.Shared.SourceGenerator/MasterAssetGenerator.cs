using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

namespace DragaliaAPI.Shared.SourceGenerator;

[Generator]
public class MasterAssetGenerator : IIncrementalGenerator
{
    private const string Namespace = "DragaliaAPI.Shared.MasterAsset";
    private const string AttributeName = "GenerateMasterAssetAttribute";

    private const string AttributeSourceCode = $$"""
        // <auto-generated/>

        #nullable enable

        namespace {{Namespace}};

        [System.AttributeUsage(global::System.AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
        public sealed class {{AttributeName}}<TItem> : System.Attribute
            where TItem : class
        {
            public {{AttributeName}}(string filepath)
            {
                this.Filepath = filepath;
            }

            public string Filepath { get; }
            
            public string Key { get; set; } = "Id";

            public bool Group { get; set; }
        }
        """;

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx =>
            ctx.AddSource(
                "GenerateMasterAssetAttribute.g.cs",
                SourceText.From(AttributeSourceCode, Encoding.UTF8)
            )
        );

        IncrementalValuesProvider<MasterAssetDeclaration> provider = context
            .SyntaxProvider.ForAttributeWithMetadataName(
                $"{Namespace}.{AttributeName}`1",
                static (_, _) => true,
                TransformMasterAssetDeclarations
            )
            .SelectMany(static (list, _) => list.AsEnumerable());

        context.RegisterSourceOutput(provider.Collect(), GenerateCode);
    }

    private static EquatableReadOnlyList<MasterAssetDeclaration> TransformMasterAssetDeclarations(
        GeneratorAttributeSyntaxContext context,
        CancellationToken cancellationToken
    )
    {
        cancellationToken.ThrowIfCancellationRequested();

        return ProcessDeclarations(context, cancellationToken).ToEquatableReadOnlyList();

        static IEnumerable<MasterAssetDeclaration> ProcessDeclarations(
            GeneratorAttributeSyntaxContext context,
            CancellationToken cancellationToken
        )
        {
            foreach (AttributeData? attribute in context.Attributes)
            {
                cancellationToken.ThrowIfCancellationRequested();

                if (attribute.AttributeClass is not { TypeArguments: [{ } itemTypeSymbol] })
                {
                    continue;
                }

                if (
                    attribute.ConstructorArguments.Length < 1
                    || attribute.ConstructorArguments[0].Value is not string jsonPath
                )
                {
                    continue;
                }

                if (
                    attribute.NamedArguments.FirstOrDefault(x => x.Key == "Key").Value
                    is not { Value: string keyName }
                )
                {
                    keyName = "Id";
                }

                bool isGroup =
                    attribute.NamedArguments.FirstOrDefault(x => x.Key == "Group").Value
                        is { Value: true };

                if (
                    itemTypeSymbol.GetMembers(keyName).FirstOrDefault()
                    is not IPropertySymbol keyPropertySymbol
                )
                {
                    continue;
                }

                ITypeSymbol keyTypeSymbol = keyPropertySymbol.Type;

                yield return new MasterAssetDeclaration(
                    keyTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                    itemTypeSymbol.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                    jsonPath,
                    keyName,
                    isGroup
                );
            }
        }
    }

    private static void GenerateCode(
        SourceProductionContext context,
        ImmutableArray<MasterAssetDeclaration> declarations
    )
    {
        const string masterAssetTypeName = "global::DragaliaAPI.Shared.MasterAsset.MasterAssetData";
        const string masterAssetGroupTypeName =
            "global::DragaliaAPI.Shared.MasterAsset.MasterAssetGroup";

        CodeStringBuilder codeBuilder = new();
        codeBuilder.AppendLine(
            $$"""
            // <auto-generated/>

            #nullable enable

            namespace {{Namespace}};

            public static partial class MasterAsset
            {
            """
        );

        codeBuilder.IncreaseIndent();

        codeBuilder.AppendLine(
            """
            private const string ErrorUninitialized = "Property access failed: MasterAsset is not yet initialized. Call LoadAsync before accessing any properties.";

            private static bool loaded;
            """
        );

        foreach (MasterAssetDeclaration declaration in declarations)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            codeBuilder.AppendLine();

            string propertyName = declaration.PropertyName;
            string fieldName = declaration.FieldName;

            // The outer key in MasterAssetGroup is restricted to be int when using this generator.
            // Can revisit this if other types are required later.
            string typeName = declaration.IsGroup
                ? $"{masterAssetGroupTypeName}<int, {declaration.FullyQualifiedKeyTypeName}, {declaration.FullyQualifiedItemTypeName}>"
                : $"{masterAssetTypeName}<{declaration.FullyQualifiedKeyTypeName}, {declaration.FullyQualifiedItemTypeName}>";

            codeBuilder.AppendLine($"private static {typeName}? {fieldName};");

            codeBuilder.AppendLine(
                $"public static {typeName} {propertyName} => {fieldName} ?? throw new InvalidOperationException(ErrorUninitialized);"
            );
        }

        codeBuilder.AppendLine(
            $$"""
            public static async Task LoadAsync()
            {
            """
        );

        codeBuilder.IncreaseIndent();

        codeBuilder.AppendLine(
            """
            if (loaded)
            {
                return;
            }
            """
        );

        foreach (MasterAssetDeclaration declaration in declarations)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            string msgpackPath = declaration.JsonPath.Replace(".json", ".msgpack");
            string taskName = declaration.TaskName;

            string typeName = declaration.IsGroup
                ? $"{masterAssetGroupTypeName}<int, {declaration.FullyQualifiedKeyTypeName}, {declaration.FullyQualifiedItemTypeName}>"
                : $"{masterAssetTypeName}<{declaration.FullyQualifiedKeyTypeName}, {declaration.FullyQualifiedItemTypeName}>";

            string loadMethodName = declaration.IsGroup
                ? $"{masterAssetGroupTypeName}.LoadAsync<int, {declaration.FullyQualifiedKeyTypeName}, {declaration.FullyQualifiedItemTypeName}>"
                : $"{masterAssetTypeName}.LoadAsync<{declaration.FullyQualifiedKeyTypeName}, {declaration.FullyQualifiedItemTypeName}>";

            codeBuilder.AppendLine(
                $"""
                global::System.Threading.Tasks.ValueTask<{typeName}> {taskName} =
                    {loadMethodName}(
                        "{msgpackPath}",
                        x => x.{declaration.KeyName}
                    );
                """
            );
        }

        codeBuilder.AppendLine();

        foreach (MasterAssetDeclaration declaration in declarations)
        {
            context.CancellationToken.ThrowIfCancellationRequested();

            codeBuilder.AppendLine($"{declaration.FieldName} = await {declaration.TaskName};");
        }

        codeBuilder.AppendLine("loaded = true;");
        codeBuilder.DecreaseIndent();
        codeBuilder.AppendLine("}");
        codeBuilder.DecreaseIndent();
        codeBuilder.AppendLine("}");

        context.AddSource(
            "MasterAsset.g.cs",
            SourceText.From(codeBuilder.ToString(), Encoding.UTF8)
        );
    }

    private readonly record struct MasterAssetDeclaration(
        string FullyQualifiedKeyTypeName,
        string FullyQualifiedItemTypeName,
        string JsonPath,
        string KeyName,
        bool IsGroup,
        string PropertyName,
        string FieldName,
        string TaskName
    )
    {
        public MasterAssetDeclaration(
            string FullyQualifiedKeyTypeName,
            string FullyQualifiedItemTypeName,
            string JsonPath,
            string KeyName,
            bool IsGroup
        )
            : this(
                FullyQualifiedKeyTypeName,
                FullyQualifiedItemTypeName,
                JsonPath,
                KeyName,
                IsGroup,
                GetPropertyName(JsonPath),
                GetFieldName(JsonPath),
                GetTaskName(JsonPath)
            ) { }

        private static string GetPropertyName(string jsonPath)
        {
            string rawPath = jsonPath.Replace(".json", "");
            return rawPath.Split('/')[^1];
        }

        private static string GetFieldName(string jsonPath)
        {
            string propertyName = GetPropertyName(jsonPath);
            return new string([char.ToLower(propertyName[0]), .. propertyName[1..]]);
        }

        private static string GetTaskName(string jsonPath) => $"{GetFieldName(jsonPath)}Task";
    }
}
